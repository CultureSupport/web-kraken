<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Camera Filter Studio</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font -->
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .filter-button {
            @apply px-4 py-2 text-sm font-medium text-white rounded-lg transition duration-150 shadow-md hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50;
        }
        /* Custom styles for the visual feedback when camera is active */
        #filter-canvas {
            transform: scaleX(-1); /* Mirror the image for a 'selfie' effect */
            background: #1f2937;
            border: 4px solid #4f46e5;
        }
        /* Hide the raw video element, we only use it as a source for the canvas */
        #live-video {
            display: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <div id="app-container" class="w-full max-w-4xl bg-white p-6 md:p-10 rounded-xl shadow-2xl">
        <h1 class="text-3xl font-extrabold text-gray-800 text-center mb-6">Live Filter Studio <span class="text-indigo-600">Pro</span></h1>
        
        <!-- Live Feed and Canvas Area -->
        <div class="relative w-full aspect-video rounded-xl overflow-hidden mb-6">
            <div id="message-box" class="absolute inset-0 flex items-center justify-center bg-gray-900/90 text-white text-center p-4 z-10 hidden">
                <div class="text-lg font-semibold animate-pulse">
                    Please click "Start Camera" and allow webcam access...
                </div>
            </div>
            
            <!-- Hidden video element to capture the stream -->
            <video id="live-video" class="w-full h-full object-cover" autoplay playsinline></video>
            
            <!-- Visible canvas element to display the filtered stream -->
            <canvas id="filter-canvas" class="w-full h-full object-cover"></canvas>
        </div>

        <!-- Filter Selection and Controls -->
        <div class="flex flex-col md:flex-row items-center justify-between gap-4 mb-8">
            <button id="start-camera-btn" class="w-full md:w-auto filter-button bg-green-600 hover:bg-green-700">
                Start Camera
            </button>
            <div class="w-full md:w-auto flex items-center justify-center gap-2">
                <label for="filter-select" class="text-gray-700 font-medium whitespace-nowrap">Select Filter:</label>
                <select id="filter-select" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:border-indigo-500 focus:ring-indigo-500 w-full md:w-60 bg-white">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
        </div>

        <!-- Filter Explanation Area -->
        <p id="filter-description" class="text-center text-sm text-gray-500 italic min-h-[1.5rem]">Filter description will appear here.</p>
    </div>

    <script>
        // --- Configuration ---
        const videoElement = document.getElementById('live-video');
        const canvasElement = document.getElementById('filter-canvas');
        const ctx = canvasElement.getContext('2d', { willReadFrequently: true });
        const filterSelect = document.getElementById('filter-select');
        const startCameraBtn = document.getElementById('start-camera-btn');
        const messageBox = document.getElementById('message-box');
        const filterDescription = document.getElementById('filter-description');

        // Initial setup
        let currentFilterKey = 'none';
        let isCameraActive = false;

        // --- Filter Definitions (Total 25) ---
        // Filters are divided into two types: CSS (string) and Canvas (function)
        const FILTERS = {
            // Group 1: Standard/Simple CSS Filters (GPU Accelerated) - 15 Filters
            'none': { type: 'css', value: 'none', desc: 'No filter applied. Pure live video feed.' },
            'grayscale-100': { type: 'css', value: 'grayscale(100%)', desc: 'Converts the entire image to black and white.' },
            'sepia-100': { type: 'css', value: 'sepia(100%)', desc: 'Applies a warm, vintage sepia tone.' },
            'contrast-2x': { type: 'css', value: 'contrast(200%)', desc: 'Doubles the color contrast for a dramatic look.' },
            'brightness-150': { type: 'css', value: 'brightness(150%)', desc: 'Increases the overall brightness by 50%.' },
            'blur-heavy': { type: 'css', value: 'blur(8px)', desc: 'Heavy gaussian blur effect.' },
            'hue-rotate-90': { type: 'css', value: 'hue-rotate(90deg)', desc: 'Shifts all colors 90 degrees on the color wheel.' },
            'invert-100': { type: 'css', value: 'invert(100%)', desc: 'Completely inverts all colors.' },
            'saturate-50': { type: 'css', value: 'saturate(50%)', desc: 'Reduces color saturation for a muted effect.' },
            'shadow-deep': { type: 'css', value: 'drop-shadow(3px 3px 5px #000)', desc: 'Adds a dark shadow to the canvas boundary.' },
            'x-ray-look': { type: 'css', value: 'invert(100%) grayscale(50%) contrast(150%)', desc: 'A high-contrast inverted grayscale effect.' },
            'dreamy-sepia': { type: 'css', value: 'sepia(80%) blur(1px) brightness(120%)', desc: 'Soft, bright, and slightly sepia-toned.' },
            'fiery-red': { type: 'css', value: 'contrast(150%) hue-rotate(330deg) saturate(200%)', desc: 'A vibrant, red-shifted high-contrast look.' },
            'aqua-shift': { type: 'css', value: 'hue-rotate(180deg) saturate(150%)', desc: 'Shifts colors towards cool blues and greens.' },
            'retro-glow': { type: 'css', value: 'sepia(30%) contrast(120%) brightness(130%)', desc: 'A gentle, warm glow reminiscent of old photos.' },
            
            // Group 2: Custom Canvas Filters (Pixel Manipulation) - 10 Filters
            'canvas-grayscale': { type: 'canvas', func: applyGrayscale, desc: 'Custom grayscale applied via pixel data manipulation.' },
            'canvas-invert': { type: 'canvas', func: applyInvert, desc: 'Custom color inversion applied via pixel data manipulation.' },
            'canvas-red-tint': { type: 'canvas', func: applyRedTint, desc: 'Boosts the Red channel by 50%.' },
            'canvas-blue-tint': { type: 'canvas', func: applyBlueTint, desc: 'Boosts the Blue channel by 50%.' },
            'canvas-green-tint': { type: 'canvas', func: applyGreenTint, desc: 'Boosts the Green channel by 50%.' },
            'canvas-posterize': { type: 'canvas', func: applyPosterize, desc: 'Reduces the color palette for a flat, graphic look.' },
            'canvas-cartoon-lite': { type: 'canvas', func: applyCartoonLite, desc: 'Simulated edge-detection and color simplification for a cartoon effect.' },
            'canvas-threshold': { type: 'canvas', func: applyThreshold, desc: 'Converts image to stark black and white based on luminosity.' },
            'canvas-warm-balance': { type: 'canvas', func: applyColorBalanceWarm, desc: 'Increases Red and Green channels for a warm, sunny feel.' },
            'canvas-cool-balance': { type: 'canvas', func: applyColorBalanceCool, desc: 'Increases Blue channel and decreases Red for a cool, moody feel.' },
        };

        // --- Custom Pixel Manipulation Functions (The Filter Library) ---

        /**
         * Converts the image to grayscale using luminosity method.
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyGrayscale(data) {
            for (let i = 0; i < data.length; i += 4) {
                // Calculate luminosity: (0.21 * R + 0.72 * G + 0.07 * B) - Standard NTSC
                const avg = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
                data[i] = data[i + 1] = data[i + 2] = avg;
            }
        }

        /**
         * Inverts all color channels.
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyInvert(data) {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];     // R
                data[i + 1] = 255 - data[i + 1]; // G
                data[i + 2] = 255 - data[i + 2]; // B
            }
        }

        /**
         * Cartoon Lite: A combination of posterization and contrast to simulate a comic book look.
         * This uses a simple color banding (posterization) technique.
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyCartoonLite(data) {
            const levels = 6; // Number of discrete color levels
            const size = 255 / levels; // Size of each color step

            for (let i = 0; i < data.length; i += 4) {
                // Simplified color banding (Posterize)
                data[i] = Math.floor(data[i] / size) * size;
                data[i + 1] = Math.floor(data[i + 1] / size) * size;
                data[i + 2] = Math.floor(data[i + 2] / size) * size;
            }
        }

        /**
         * Applies a Red color tint.
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyRedTint(data) {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.5); // Boost Red
            }
        }

        /**
         * Applies a Blue color tint.
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyBlueTint(data) {
            for (let i = 0; i < data.length; i += 4) {
                data[i + 2] = Math.min(255, data[i + 2] * 1.5); // Boost Blue
            }
        }

        /**
         * Applies a Green color tint.
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyGreenTint(data) {
            for (let i = 0; i < data.length; i += 4) {
                data[i + 1] = Math.min(255, data[i + 1] * 1.5); // Boost Green
            }
        }

        /**
         * Posterizes the image (similar to Cartoon-Lite but with more levels).
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyPosterize(data) {
            const levels = 8;
            const size = 255 / (levels - 1);
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.floor(data[i] / size) * size;
                data[i + 1] = Math.floor(data[i + 1] / size) * size;
                data[i + 2] = Math.floor(data[i + 2] / size) * size;
            }
        }

        /**
         * Converts the image to stark black and white (Threshold).
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyThreshold(data) {
            const threshold = 128;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                const color = avg > threshold ? 255 : 0;
                data[i] = data[i + 1] = data[i + 2] = color;
            }
        }

        /**
         * Warms the color balance (more red/less blue).
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyColorBalanceWarm(data) {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.15);     // Boost R
                data[i + 2] = Math.max(0, data[i + 2] * 0.85); // Reduce B
            }
        }

        /**
         * Cools the color balance (less red/more blue).
         * @param {Uint8ClampedArray} data - The pixel data array (R, G, B, A).
         */
        function applyColorBalanceCool(data) {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, data[i] * 0.85);     // Reduce R
                data[i + 2] = Math.min(255, data[i + 2] * 1.15); // Boost B
            }
        }

        // --- Main Application Logic ---

        /**
         * Continuously draws the video feed to the canvas and applies the selected filter.
         */
        function processFrame() {
            if (videoElement.paused || videoElement.ended || !isCameraActive) {
                return;
            }

            // 1. Draw the frame from the video onto the canvas
            ctx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

            const filter = FILTERS[currentFilterKey];

            // 2. Apply Canvas (Pixel) Filters if needed
            if (filter.type === 'canvas') {
                try {
                    // Get the pixel data from the canvas
                    let imageData = ctx.getImageData(0, 0, canvasElement.width, canvasElement.height);

                    // Apply the custom filter function
                    filter.func(imageData.data);

                    // Put the modified data back onto the canvas
                    ctx.putImageData(imageData, 0, 0);
                } catch (e) {
                    // This block helps catch errors if the context state is bad
                    console.error("Canvas filter error:", e);
                }
            }

            // 3. Request the next frame draw
            requestAnimationFrame(processFrame);
        }

        /**
         * Initializes and starts the camera stream.
         */
        async function startCamera() {
            if (isCameraActive) return;

            messageBox.classList.remove('hidden');
            startCameraBtn.disabled = true;
            startCameraBtn.textContent = 'Starting...';

            // Get media stream from user camera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user' // Prefer front camera on mobile
                    }
                });
                videoElement.srcObject = stream;
                isCameraActive = true;
                
                // When video metadata is loaded, set canvas dimensions
                videoElement.onloadedmetadata = () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    messageBox.classList.add('hidden');
                    startCameraBtn.textContent = 'Stop Camera';
                    startCameraBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    startCameraBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                    startCameraBtn.disabled = false;
                    processFrame(); // Start the filter loop
                };

            } catch (error) {
                console.error("Could not access camera:", error);
                const message = error.name === 'NotAllowedError' ? 
                                "Camera access denied. Please allow it in your browser settings." :
                                "Error: Could not find or access camera device.";
                
                messageBox.innerHTML = `<div class="text-xl font-bold">${message}</div>`;
                startCameraBtn.textContent = 'Start Camera';
                startCameraBtn.disabled = false;
                startCameraBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                startCameraBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            }
        }

        /**
         * Stops the camera stream.
         */
        function stopCamera() {
            if (!isCameraActive) return;
            const stream = videoElement.srcObject;
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            isCameraActive = false;
            startCameraBtn.textContent = 'Start Camera';
            startCameraBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            startCameraBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            messageBox.classList.remove('hidden');
            messageBox.innerHTML = `<div class="text-lg font-semibold animate-pulse">Camera stopped. Click "Start Camera" to begin again.</div>`;
        }


        /**
         * Applies the selected filter, using either CSS or Canvas methods.
         */
        function applyFilter(key) {
            const filter = FILTERS[key];
            if (!filter) return;
            
            currentFilterKey = key;
            filterDescription.textContent = filter.desc;

            // 1. Reset all CSS filters
            canvasElement.style.filter = 'none';

            // 2. Apply CSS filter if type is 'css'
            if (filter.type === 'css') {
                canvasElement.style.filter = filter.value;
            }
            
            // Note: If type is 'canvas', the filter is applied inside the requestAnimationFrame loop (processFrame)
        }

        // --- Initialization ---
        
        // Populate the dropdown menu with filters
        Object.keys(FILTERS).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = key.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            filterSelect.appendChild(option);
        });

        // Set initial message
        messageBox.classList.remove('hidden');
        
        // Event Listeners
        startCameraBtn.addEventListener('click', () => {
            if (isCameraActive) {
                stopCamera();
            } else {
                startCamera();
            }
        });

        filterSelect.addEventListener('change', (e) => {
            applyFilter(e.target.value);
        });

        // Apply initial filter
        applyFilter(currentFilterKey);

    </script>
</body>
</html>

